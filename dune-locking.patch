From dcd622f8123b8f220e68f3e67e80f046e84425be Mon Sep 17 00:00:00 2001
From: Etienne Marais <dev@maiste.fr>
Date: Tue, 27 Aug 2024 12:32:08 +0200
Subject: [PATCH 1/5] tmp: prepare for atomic lock

---
 src/dune_pkg/lock_dir.ml | 92 ++++++++++++++++++++++++++++++----------
 1 file changed, 70 insertions(+), 22 deletions(-)

diff --git a/src/dune_pkg/lock_dir.ml b/src/dune_pkg/lock_dir.ml
index cb4efcc0e..c2092128a 100644
--- a/src/dune_pkg/lock_dir.ml
+++ b/src/dune_pkg/lock_dir.ml
@@ -498,6 +498,32 @@ module Write_disk = struct
     | Ok _ -> Error `Not_directory
   ;;
 
+  let raise_user_error_on_check_existance path e =
+    let error_reason_pp =
+      match e with
+      | `Unreadable -> Pp.text "Unable to read lock directory"
+      | `Not_directory -> Pp.text "Specified lock dir path is not a directory"
+      | `No_metadata_file ->
+        Pp.textf "Specified lock dir lacks metadata file (%s)" metadata_filename
+      | `Failed_to_parse_metadata (path, exn) ->
+        Pp.concat
+          ~sep:Pp.cut
+          [ Pp.textf
+              "Unable to parse lock directory metadata file (%s):"
+              (Path.to_string_maybe_quoted path)
+            |> Pp.hovbox
+          ; Exn.pp exn |> Pp.hovbox
+          ]
+        |> Pp.vbox
+    in
+    User_error.raise
+      [ Pp.textf
+          "Refusing to regenerate lock directory %s"
+          (Path.to_string_maybe_quoted path)
+      ; error_reason_pp
+      ]
+  ;;
+
   (* Removes the existing lock directory at the specified path if it exists and
      is a valid lock directory. Checks the validity of the existing lockdir (if
      any) and raises if it's invalid before constructing the returned thunk, so
@@ -507,23 +533,20 @@ module Write_disk = struct
     match check_existing_lock_dir path with
     | Ok `Non_existant -> Fun.const ()
     | Ok `Is_existing_lock_dir -> fun () -> Path.rm_rf path
-    | Error e ->
+    | Error e -> raise_user_error_on_check_existance path e
+  ;;
+
+  (* Does the same checks as [safely_remove_lock_dir_if_exists_thunk] but it raises an
+     error if the lock dir already exists. [dst] is the new file name *)
+  let safely_rename_lock_dir ~dst path =
+    match check_existing_lock_dir dst, check_existing_lock_dir path with
+    | Ok `Non_existant, Ok `Is_existing_lock_dir -> fun () -> Path.rename path dst
+    | Ok `Non_existant, Ok `Non_existant -> Fun.const ()
+    | Ok `Is_existing_lock_dir, _ ->
       let error_reason_pp =
-        match e with
-        | `Unreadable -> Pp.text "Unable to read lock directory"
-        | `Not_directory -> Pp.text "Specified lock dir path is not a directory"
-        | `No_metadata_file ->
-          Pp.textf "Specified lock dir lacks metadata file (%s)" metadata_filename
-        | `Failed_to_parse_metadata (path, exn) ->
-          Pp.concat
-            ~sep:Pp.cut
-            [ Pp.textf
-                "Unable to parse lock directory metadata file (%s):"
-                (Path.to_string_maybe_quoted path)
-              |> Pp.hovbox
-            ; Exn.pp exn |> Pp.hovbox
-            ]
-          |> Pp.vbox
+        Pp.textf
+          "Directory %s already exists: can't rename safely"
+          (Path.to_string_maybe_quoted path)
       in
       User_error.raise
         [ Pp.textf
@@ -531,15 +554,31 @@ module Write_disk = struct
             (Path.to_string_maybe_quoted path)
         ; error_reason_pp
         ]
+    | Error e, _ | _, Error e -> raise_user_error_on_check_existance path e
   ;;
 
   type t = unit -> unit
 
-  let prepare ~lock_dir_path:lock_dir_path_src ~files lock_dir =
-    let lock_dir_path = Path.source lock_dir_path_src in
-    let remove_dir_if_exists = safely_remove_lock_dir_if_exists_thunk lock_dir_path in
-    fun () ->
-      remove_dir_if_exists ();
+  let prepare
+    ~lock_dir_path:lock_dir_path_src
+    ~(files : File_entry.t Package_name.Map.Multi.t)
+    lock_dir
+    =
+    let lock_dir_hidden_src =
+      Format.sprintf ".%s" (Path.Source.to_string lock_dir_path_src)
+      |> Path.Source.of_string
+    in
+    let lock_dir_hidden_src = Path.source lock_dir_hidden_src in
+    let lock_dir_path_external = Path.source lock_dir_path_src in
+    let remove_hidden_dir_if_exists =
+      safely_remove_lock_dir_if_exists_thunk lock_dir_hidden_src
+    in
+    let rename_old_lock_dir_to_hidden =
+      safely_rename_lock_dir ~dst:lock_dir_hidden_src lock_dir_path_external
+    in
+    let build lock_dir_path =
+      rename_old_lock_dir_to_hidden ();
+      let lock_dir_path = Result.ok_exn lock_dir_path in
       Path.mkdir_p lock_dir_path;
       file_contents_by_path lock_dir
       |> List.iter ~f:(fun (path_within_lock_dir, contents) ->
@@ -563,7 +602,16 @@ module Write_disk = struct
             Path.mkdir_p (Path.parent_exn dst);
             match original with
             | Path src -> Io.copy_file ~src ~dst ()
-            | Content content -> Io.write_file dst content)))
+            | Content content -> Io.write_file dst content)));
+      safely_rename_lock_dir ~dst:lock_dir_path_external lock_dir_path ();
+      remove_hidden_dir_if_exists ()
+    in
+    fun () ->
+      Temp.with_temp_dir
+        ~parent_dir:(Path.of_string "/tmp")
+        ~prefix:"dune"
+        ~suffix:"lock"
+        ~f:build
   ;;
 
   let commit t = t ()
-- 
2.46.0


From 84e57d72c3c0637bea24fe0095274d86aaa4c45c Mon Sep 17 00:00:00 2001
From: Stephen Sherratt <stephen@sherra.tt>
Date: Tue, 27 Aug 2024 22:34:21 +1000
Subject: [PATCH 2/5] Minor fixes to atomic locking

Signed-off-by: Stephen Sherratt <stephen@sherra.tt>
---
 src/dune_pkg/lock_dir.ml | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/dune_pkg/lock_dir.ml b/src/dune_pkg/lock_dir.ml
index c2092128a..e1a74f0c1 100644
--- a/src/dune_pkg/lock_dir.ml
+++ b/src/dune_pkg/lock_dir.ml
@@ -579,7 +579,6 @@ module Write_disk = struct
     let build lock_dir_path =
       rename_old_lock_dir_to_hidden ();
       let lock_dir_path = Result.ok_exn lock_dir_path in
-      Path.mkdir_p lock_dir_path;
       file_contents_by_path lock_dir
       |> List.iter ~f:(fun (path_within_lock_dir, contents) ->
         let path = Path.relative lock_dir_path path_within_lock_dir in
@@ -594,7 +593,7 @@ module Write_disk = struct
         Format.asprintf "%a" Pp.to_fmt pp |> Io.write_file path;
         Package_name.Map.iteri files ~f:(fun package_name files ->
           let files_dir =
-            Pkg.files_dir package_name ~lock_dir:lock_dir_path_src |> Path.source
+            Path.relative lock_dir_path (Package_name.to_string package_name ^ ".files")
           in
           Path.mkdir_p files_dir;
           List.iter files ~f:(fun { File_entry.original; local_file } ->
@@ -608,7 +607,7 @@ module Write_disk = struct
     in
     fun () ->
       Temp.with_temp_dir
-        ~parent_dir:(Path.of_string "/tmp")
+        ~parent_dir:(Path.source Path.Source.root)
         ~prefix:"dune"
         ~suffix:"lock"
         ~f:build
-- 
2.46.0


From dbe95d051cd1199c4e958fdacd3ab9aa35733dca Mon Sep 17 00:00:00 2001
From: Etienne Marais <dev@maiste.fr>
Date: Thu, 22 Aug 2024 11:58:26 +0200
Subject: [PATCH 3/5] tmp: ask to re run dune pkg lock on change

---
 bin/build_cmd.ml                  | 34 ++++++++++++++++++++++++++++++-
 bin/pkg/pkg_common.ml             |  2 ++
 bin/pkg/pkg_common.mli            |  4 ++++
 src/dune_pkg/package_universe.ml  | 19 +++++++++++++++++
 src/dune_pkg/package_universe.mli |  8 ++++++++
 5 files changed, 66 insertions(+), 1 deletion(-)

diff --git a/bin/build_cmd.ml b/bin/build_cmd.ml
index b7e09e8fe..973b26f2b 100644
--- a/bin/build_cmd.ml
+++ b/bin/build_cmd.ml
@@ -30,6 +30,34 @@ let with_metrics ~common f =
     Fiber.return ())
 ;;
 
+let raise_on_lock_dir_out_of_sync () =
+  Memo.of_thunk (fun () ->
+    let open Memo.O in
+    let lock_dir_path = Dune_pkg.Lock_dir.default_path in
+    let lock_dirs = Pkg_common.Lock_dirs_arg.of_path lock_dir_path in
+    let* per_contexts =
+      Workspace.workspace () >>| Pkg_common.Lock_dirs_arg.lock_dirs_of_workspace lock_dirs
+    in
+    let lock_dirs =
+      List.filter_map per_contexts ~f:(fun lock_dir_path ->
+        match Path.exists (Path.source lock_dir_path) with
+        | true -> Some (Dune_pkg.Lock_dir.read_disk lock_dir_path)
+        | false -> None)
+    in
+    match lock_dirs with
+    | [] -> Memo.return ()
+    | lock_dirs ->
+      let* local_packages = Pkg_common.find_local_packages in
+      let locks =
+        List.map lock_dirs ~f:(fun lock_dir ->
+          match Dune_pkg.Package_universe.up_to_date local_packages lock_dir with
+          | `Valid -> Memo.return ()
+          | `Invalid _ -> User_error.raise [ Pp.text "STOPPPPPPPP! Rerun pk lock" ])
+      in
+      let+ (_ : unit list) = Memo.all_concurrently locks in
+      ())
+;;
+
 let run_build_system ~common ~request =
   let run ~(toplevel : unit Memo.Lazy.t) =
     with_metrics ~common (fun () -> build (fun () -> Memo.Lazy.force toplevel))
@@ -46,8 +74,12 @@ let run_build_system ~common ~request =
          worth the effort. *)
       Cached_digest.invalidate_cached_timestamps ();
       let* setup = Import.Main.setup () in
+      let setup_with_check =
+        Memo.bind (raise_on_lock_dir_out_of_sync ()) ~f:(fun () -> setup)
+      in
       let request =
-        Action_builder.bind (Action_builder.of_memo setup) ~f:(fun setup -> request setup)
+        Action_builder.bind (Action_builder.of_memo setup_with_check) ~f:(fun setup ->
+          request setup)
       in
       (* CR-someday cmoseley: Can we avoid creating a new lazy memo node every
          time the build system is rerun? *)
diff --git a/bin/pkg/pkg_common.ml b/bin/pkg/pkg_common.ml
index d5f04f5bc..fd897dfc6 100644
--- a/bin/pkg/pkg_common.ml
+++ b/bin/pkg/pkg_common.ml
@@ -136,6 +136,8 @@ module Lock_dirs_arg = struct
        All)
   ;;
 
+  let of_path p = Selected [ p ]
+
   let lock_dirs_of_workspace t (workspace : Workspace.t) =
     let workspace_lock_dirs =
       Lock_dir.default_path
diff --git a/bin/pkg/pkg_common.mli b/bin/pkg/pkg_common.mli
index 090129f42..865ec87a9 100644
--- a/bin/pkg/pkg_common.mli
+++ b/bin/pkg/pkg_common.mli
@@ -62,6 +62,10 @@ module Lock_dirs_arg : sig
         of the workspace are considered. *)
   val term : t Term.t
 
+  (** [Lock_dirs_arg.of_path] creates a specific lock dir argument out of a
+      source path *)
+  val of_path : Path.Source.t -> t
+
   (** [Lock_dirs_arg.lock_dirs_of_workspace t workspace] returns the list of
       lock directories that should be considered for various operations.
 
diff --git a/src/dune_pkg/package_universe.ml b/src/dune_pkg/package_universe.ml
index 74a7005a5..ece1360f8 100644
--- a/src/dune_pkg/package_universe.ml
+++ b/src/dune_pkg/package_universe.ml
@@ -127,6 +127,25 @@ let check_for_unnecessary_packges_in_lock_dir
       ])
 ;;
 
+let up_to_date local_packages (lock_dir : Lock_dir.t) =
+  let local_packages =
+    Package_name.Map.values local_packages |> List.map ~f:Local_package.for_solver
+  in
+  let non_local_dependencies =
+    Local_package.For_solver.list_non_local_dependency_set local_packages
+  in
+  let dependency_hash = Local_package.Dependency_set.hash non_local_dependencies in
+  match lock_dir.dependency_hash, dependency_hash with
+  | None, None -> `Valid
+  | Some (_, lock_dir_dependency_hash), Some non_local_dependencies_hash
+    when Local_package.Dependency_hash.equal
+           lock_dir_dependency_hash
+           non_local_dependencies_hash -> `Valid
+  | None, Some non_local_dependencies_hash | Some _, Some non_local_dependencies_hash ->
+    `Invalid (Some non_local_dependencies_hash)
+  | Some _, None -> `Invalid None
+;;
+
 let validate_dependency_hash { local_packages; lock_dir; _ } =
   let local_packages =
     Package_name.Map.values local_packages |> List.map ~f:Local_package.for_solver
diff --git a/src/dune_pkg/package_universe.mli b/src/dune_pkg/package_universe.mli
index 2b2273fc1..ae90027d5 100644
--- a/src/dune_pkg/package_universe.mli
+++ b/src/dune_pkg/package_universe.mli
@@ -10,6 +10,14 @@ val create
   -> Lock_dir.t
   -> (t, User_message.t) result
 
+(** Verifies if the dependencies described in the project file are still
+    synchronize with the dependencies selected in the lock directroy. If it is
+    not the case, it returns the hash of the new dependency set. *)
+val up_to_date
+  :  Local_package.t Package_name.Map.t
+  -> Lock_dir.t
+  -> [ `Valid | `Invalid of Local_package.Dependency_hash.t option ]
+
 (** Returns the dependencies of the specified package within the package
     universe *)
 val opam_package_dependencies_of_package
-- 
2.46.0


From 5d37071194aae35ea5563818646a73f80f5e34ba Mon Sep 17 00:00:00 2001
From: Etienne Marais <dev@maiste.fr>
Date: Tue, 27 Aug 2024 15:16:27 +0200
Subject: [PATCH 4/5] fix: turn into a closure

---
 src/dune_pkg/lock_dir.ml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/dune_pkg/lock_dir.ml b/src/dune_pkg/lock_dir.ml
index e1a74f0c1..262196a4c 100644
--- a/src/dune_pkg/lock_dir.ml
+++ b/src/dune_pkg/lock_dir.ml
@@ -570,8 +570,8 @@ module Write_disk = struct
     in
     let lock_dir_hidden_src = Path.source lock_dir_hidden_src in
     let lock_dir_path_external = Path.source lock_dir_path_src in
-    let remove_hidden_dir_if_exists =
-      safely_remove_lock_dir_if_exists_thunk lock_dir_hidden_src
+    let remove_hidden_dir_if_exists () =
+      safely_remove_lock_dir_if_exists_thunk lock_dir_hidden_src ()
     in
     let rename_old_lock_dir_to_hidden =
       safely_rename_lock_dir ~dst:lock_dir_hidden_src lock_dir_path_external
-- 
2.46.0


From b2ff378265b6844bfbb464303125e7b3008f584b Mon Sep 17 00:00:00 2001
From: Etienne Marais <dev@maiste.fr>
Date: Tue, 27 Aug 2024 16:09:44 +0200
Subject: [PATCH 5/5] feat: improve out of date message

---
 bin/build_cmd.ml | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/bin/build_cmd.ml b/bin/build_cmd.ml
index 973b26f2b..15b9c9312 100644
--- a/bin/build_cmd.ml
+++ b/bin/build_cmd.ml
@@ -52,7 +52,9 @@ let raise_on_lock_dir_out_of_sync () =
         List.map lock_dirs ~f:(fun lock_dir ->
           match Dune_pkg.Package_universe.up_to_date local_packages lock_dir with
           | `Valid -> Memo.return ()
-          | `Invalid _ -> User_error.raise [ Pp.text "STOPPPPPPPP! Rerun pk lock" ])
+          | `Invalid _ ->
+            let hints = Pp.[ text "run dune pkg lock" ] in
+            User_error.raise ~hints [ Pp.text "The lock dir is not sync with your dune-project" ])
       in
       let+ (_ : unit list) = Memo.all_concurrently locks in
       ())
-- 
2.46.0

